{new
   MidiParser
   guitar_timer
   (track_name 'PART GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type strum_no_flags)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_guitar_gem_tracked
         {set $first_guitar_gem_tracked TRUE}
         {set $first_guitar_gem_beat $mp.start}
      }
      {if {&& {> $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $guitar_tracked_number {- $mp.start $mp.prev_start}}
         {foreach $entry $guitar_note_tracker
            {if {== {elem $entry 0} {sprint $guitar_tracked_number}}
               {remove_elem {find $guitar_note_tracker {sprint $guitar_tracked_number}} {elem {find $guitar_note_tracker {sprint $guitar_tracked_number}} 1}}
               {push_back $guitar_note_tracker ({sprint $guitar_tracked_number} $mp.start)}
            }
         }
         {foreach $entry $guitar_note_tracker
            {if {!= {elem $entry 0} {sprint $guitar_tracked_number}}
               {set $pushtime TRUE} ;get ready to push it
            }
         }
         {foreach $entry $guitar_note_tracker
            {if {== {elem $entry 0} {sprint $guitar_tracked_number}}
               {set $pushtime FALSE} ;dont push it
            }
         }
         {if $pushtime ;if we need to push
            {push_back $guitar_note_tracker ({sprint $guitar_tracked_number} $mp.start)}
         }
         {set $guitar_note_tracker {array $guitar_note_tracker}}
         ;{dx_log_writer TRUE $guitar_note_tracker}
      }
   )
}
{new
   MidiParser
   drum_timer
   (track_name 'PART DRUMS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type strum_no_flags)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_drum_gem_tracked
         {set $first_drum_gem_tracked TRUE}
         {set $first_drum_gem_beat $mp.start}
      }
      {if {&& {> $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $drum_tracked_number {- $mp.start $mp.prev_start}}
         {foreach $entry $drum_note_tracker
            {if {== {elem $entry 0} {sprint $drum_tracked_number}}
               {remove_elem {find $drum_note_tracker {sprint $drum_tracked_number}} {elem {find $drum_note_tracker {sprint $drum_tracked_number}} 1}}
               {push_back $drum_note_tracker ({sprint $drum_tracked_number} $mp.start)}
            }
         }
         {foreach $entry $drum_note_tracker
            {if {!= {elem $entry 0} {sprint $drum_tracked_number}}
               {set $pushtime TRUE} ;get ready to push it
            }
         }
         {foreach $entry $drum_note_tracker
            {if {== {elem $entry 0} {sprint $drum_tracked_number}}
               {set $pushtime FALSE} ;dont push it
            }
         }
         {if $pushtime ;if we need to push
            {push_back $drum_note_tracker ({sprint $drum_tracked_number} $mp.start)}
         }
         {set $drum_note_tracker {array $drum_note_tracker}}
         ;{dx_log_writer TRUE $drum_note_tracker}
      }
   )
}
{new
   MidiParser
   bass_timer
   (track_name 'PART BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type strum_no_flags)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_bass_gem_tracked
         {set $first_bass_gem_tracked TRUE}
         {set $first_bass_gem_beat $mp.start}
      }
      {if {&& {> $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $bass_tracked_number {- $mp.start $mp.prev_start}}
         {foreach $entry $bass_note_tracker
            {if {== {elem $entry 0} {sprint $bass_tracked_number}}
               {remove_elem {find $bass_note_tracker {sprint $bass_tracked_number}} {elem {find $bass_note_tracker {sprint $bass_tracked_number}} 1}}
               {push_back $bass_note_tracker ({sprint $bass_tracked_number} $mp.start)}
            }
         }
         {foreach $entry $bass_note_tracker
            {if {!= {elem $entry 0} {sprint $bass_tracked_number}}
               {set $pushtime TRUE} ;get ready to push it
            }
         }
         {foreach $entry $bass_note_tracker
            {if {== {elem $entry 0} {sprint $bass_tracked_number}}
               {set $pushtime FALSE} ;dont push it
            }
         }
         {if $pushtime ;if we need to push
            {push_back $bass_note_tracker ({sprint $bass_tracked_number} $mp.start)}
         }
         {set $bass_note_tracker {array $bass_note_tracker}}
         ;{dx_log_writer TRUE $bass_note_tracker}
      }
   )
}
{new
   MidiParser
   keys_timer
   (track_name 'PART KEYS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type strum_no_flags)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_keys_gem_tracked
         {set $first_keys_gem_tracked TRUE}
         {set $first_keys_gem_beat $mp.start}
      }
      {if {&& {> $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $keys_tracked_number {- $mp.start $mp.prev_start}}
         {foreach $entry $keys_note_tracker
            {if {== {elem $entry 0} {sprint $keys_tracked_number}}
               {remove_elem {find $keys_note_tracker {sprint $keys_tracked_number}} {elem {find $keys_note_tracker {sprint $keys_tracked_number}} 1}}
               {push_back $keys_note_tracker ({sprint $keys_tracked_number} $mp.start)}
            }
         }
         {foreach $entry $keys_note_tracker
            {if {!= {elem $entry 0} {sprint $keys_tracked_number}}
               {set $pushtime TRUE} ;get ready to push it
            }
         }
         {foreach $entry $keys_note_tracker
            {if {== {elem $entry 0} {sprint $keys_tracked_number}}
               {set $pushtime FALSE} ;dont push it
            }
         }
         {if $pushtime ;if we need to push
            {push_back $keys_note_tracker ({sprint $keys_tracked_number} $mp.start)}
         }
         {set $keys_note_tracker {array $keys_note_tracker}}
         ;{dx_log_writer TRUE $keys_note_tracker}
      }
   )
}